<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>NoteTransform - MIDI → Minecraft (.schem)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root { --brand:#4b6cb7; --brand-dark:#182848; --green:#28a745; --orange:#f39c12; }
    body { font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif; background:#f0f2f5; margin:0; padding:0; display:flex; flex-direction:column; align-items:center; min-height:100vh; }
    header { background: linear-gradient(90deg,var(--brand-dark),var(--brand)); color:white; width:100%; text-align:center; padding:2rem; box-shadow:0 4px 12px rgba(0,0,0,0.12); }
    h1 { margin:0; font-size:1.6rem; }
    main { width:100%; max-width:980px; padding:2rem; display:flex; flex-direction:column; gap:1rem; }
    #dropZone { border:2px dashed var(--brand); border-radius:12px; padding:1.4rem; text-align:center; color:var(--brand); font-weight:600; cursor:pointer; transition:0.15s; background:white; }
    #dropZone.hover { background:var(--brand); color:white; }
    .controls { display:flex; gap:0.75rem; align-items:center; flex-wrap:wrap; }
    button, input[type=file] { padding:0.6rem 1rem; border-radius:8px; border:none; cursor:pointer; font-weight:600; font-size:0.95rem; }
    button { background:var(--brand); color:white; }
    button.secondary { background:#6c757d; }
    button.green { background:var(--green); color:white; }
    button.orange { background:var(--orange); color:white; }
    table { width:100%; border-collapse:collapse; margin-top:0.5rem; background:white; border-radius:8px; overflow:hidden; box-shadow:0 1px 6px rgba(0,0,0,0.06); }
    thead th { background:var(--brand); color:white; padding:0.8rem 1rem; text-align:left; position:sticky; top:0; }
    th, td { padding:0.7rem 1rem; border-bottom:1px solid #eee; font-size:0.95rem; }
    #tableWrap { max-height:360px; overflow:auto; border-radius:8px; }
    #status { display:flex; gap:1rem; align-items:center; flex-wrap:wrap; }
    .muted { color:#666; font-size:0.92rem; }
    progress { width:200px; height:12px; }
    .small { font-size:0.85rem; color:#444; }
    footer { padding:1rem; color:#666; font-size:0.9rem; }
  </style>
</head>
<body>
  <header>
    <h1>NoteTransform</h1>
    <p class="muted">MIDI → Minecraft note blocks — genera .schem descargable (compatible con Litematica)</p>
  </header>

  <main>
    <div id="dropZone">Arrastra y suelta tu archivo MIDI (.mid) aquí, o usa el botón de archivo</div>

    <div class="controls">
      <input type="file" id="fileInput" accept=".mid,.midi">
      <button id="processBtn">Process MIDI</button>
      <button id="downloadJsonBtn" style="display:none" class="green">Download JSON</button>
      <button id="downloadSchemBtn" style="display:none" class="orange">Download .schem</button>
      <div class="muted">El .schem coloca <code>note_block</code> + bloque soporte (determina instrumento)</div>
    </div>

    <div id="status">
      <div id="infoBPM" class="muted"></div>
      <div id="progressWrap" style="display:none">
        <progress id="progressBar" value="0" max="1"></progress>
        <div id="progressText" class="small"></div>
      </div>
    </div>

    <div id="tableWrap">
      <table id="resultTable" aria-live="polite">
        <thead>
          <tr><th style="width:100px">Tick</th><th style="width:120px">Delta</th><th>Notes (instrument &amp; note)</th></tr>
        </thead>
        <tbody id="resultBody"></tbody>
      </table>
    </div>
  </main>

  <footer>
    Listo para GitHub Pages — todo client-side. Si quieres .litematic directo o ajustes por versión de Minecraft dímelo y lo añado.
  </footer>

  <!-- Tone.js MIDI parser (global Midi) -->
  <script src="https://cdn.jsdelivr.net/npm/@tonejs/midi@2.0.27/build/Midi.js"></script>

  <!-- Main logic (module) -->
  <script type="module">
  // IMPORT: prismarine-nbt (ESM build)
  import { writeUncompressed } from "https://cdn.jsdelivr.net/npm/prismarine-nbt@2.0.0/dist/index.min.js";

  // DOM
  const dropZone = document.getElementById('dropZone');
  const fileInput = document.getElementById('fileInput');
  const processBtn = document.getElementById('processBtn');
  const downloadJsonBtn = document.getElementById('downloadJsonBtn');
  const downloadSchemBtn = document.getElementById('downloadSchemBtn');
  const resultBody = document.getElementById('resultBody');
  const infoBPM = document.getElementById('infoBPM');
  const progressWrap = document.getElementById('progressWrap');
  const progressBar = document.getElementById('progressBar');
  const progressText = document.getElementById('progressText');

  // state
  let midiFile = null;
  let lastExportData = null;

  // UI: drag & drop
  dropZone.addEventListener('click', () => fileInput.click());
  dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('hover'); });
  dropZone.addEventListener('dragleave', e => { e.preventDefault(); dropZone.classList.remove('hover'); });
  dropZone.addEventListener('drop', e => {
    e.preventDefault(); dropZone.classList.remove('hover');
    if (e.dataTransfer.files.length) {
      midiFile = e.dataTransfer.files[0];
      dropZone.textContent = `Loaded: ${midiFile.name}`;
    }
  });
  fileInput.addEventListener('change', e => {
    if (e.target.files.length) {
      midiFile = e.target.files[0];
      dropZone.textContent = `Loaded: ${midiFile.name}`;
    }
  });

  // Instrument mapping (GM program -> block + octave adjust)
  const gmProgramMap = {
    1: { name: "Harp", block: "minecraft:gold_block", octave: 0 },
    2: { name: "Pling", block: "minecraft:clay", octave: 0 },
    3: { name: "Pling", block: "minecraft:clay", octave: 0 },
    4: { name: "Pling", block: "minecraft:clay", octave: 0 },
    5: { name: "Harp", block: "minecraft:gold_block", octave: 0 },
    25:{ name: "Guitar", block: "minecraft:emerald_block", octave: 1 },
    26:{ name: "Guitar", block: "minecraft:emerald_block", octave: 1 },
    33:{ name: "Bass", block: "minecraft:stone", octave: 2 },
    41:{ name: "Flute", block: "minecraft:bone_block", octave: -1 },
    47:{ name: "Harp", block: "minecraft:gold_block", octave: 0 },
    74:{ name: "Flute", block: "minecraft:bone_block", octave: -1 },
    10:{ name: "Bells", block: "minecraft:glowstone", octave:-2 },
    14:{ name: "Xylophone", block: "minecraft:iron_block", octave:-2 },
    106:{name:"Banjo", block:"minecraft:clay", octave:0 },
    81:{ name:"Bit", block:"minecraft:redstone_block", octave:0 },
  };

  // Percussion map (MIDI pitch -> support-block, suggested note value)
  const percussionMap = {
    35: { block: "minecraft:stone", noteVal: 4 },
    36: { block: "minecraft:stone", noteVal: 8 },
    38: { block: "minecraft:gravel", noteVal: 15 },
    42: { block: "minecraft:clay", noteVal: 21 },
    46: { block: "minecraft:gravel", noteVal: 22 },
    59: { block: "minecraft:gravel", noteVal: 24 }
  };

  function clampNote(n){ return Math.max(0, Math.min(24, n)); }
  function secondsToMcTicks(s){ return Math.round(s*20); } // Minecraft 20 ticks per second
  function pickTopNotes(notes, maxCount=3){ return notes.sort((a,b)=>b.velocity - a.velocity).slice(0,maxCount); }

  // MAIN: process MIDI and populate lastExportData
  async function processMidi() {
    if (!midiFile) { alert("Please load a MIDI file first."); return; }
    resultBody.innerHTML = "";
    infoBPM.textContent = "";
    progressWrap.style.display = "none";

    const buffer = await midiFile.arrayBuffer();
    // Tone.js Midi is loaded via script tag; the global class is Midi
    const midi = new Midi(buffer);

    const defaultBpm = (midi.header && midi.header.tempos && midi.header.tempos.length>0) ? midi.header.tempos[0].bpm : 120;
    infoBPM.textContent = `Reference BPM: ${Math.round(defaultBpm)} (tempo map respected)`;

    // Build tick -> notes map using seconds->ticks (respects tempo changes)
    const tickMap = new Map();

    midi.tracks.forEach(track => {
      const programNumber = (track.instrument && typeof track.instrument.number === 'number') ? track.instrument.number + 1 : null;
      const isPercussion = !!track.isPercussion || (track.channel === 9 || track.channel === 10);

      track.notes.forEach(note => {
        const mcTick = secondsToMcTicks(note.time);
        const midiPitch = note.midi;
        const velocity = note.velocity || 0.8;

        let mapped = null;
        if (isPercussion || (midiPitch >= 35 && midiPitch <= 81 && (track.channel === 9 || track.channel === 10))) {
          const pm = percussionMap[midiPitch] || { block: "minecraft:stone", noteVal: 12 };
          mapped = { block: pm.block, note: clampNote(pm.noteVal ?? 12), name: "Percussion" };
        } else {
          const gm = programNumber || 1;
          const info = gmProgramMap[gm] || { name: "Harp", block: "minecraft:gold_block", octave: 0 };
          const base = 12 + (info.octave || 0) * 12;
          let mcNote = Math.round(midiPitch - 60 + base);
          mcNote = clampNote(mcNote);
          mapped = { block: info.block, note: mcNote, name: info.name || "Harp" };
        }

        const entry = {
          tick: mcTick,
          midi: midiPitch,
          velocity,
          instrumentName: mapped.name,
          block: mapped.block,
          note: mapped.note
        };

        if (!tickMap.has(mcTick)) tickMap.set(mcTick, []);
        tickMap.get(mcTick).push(entry);
      });
    });

    // Sort ticks & compact (pick top notes per tick)
    const ticksSorted = Array.from(tickMap.keys()).sort((a,b)=>a-b);
    const rows = ticksSorted.map(t => ({ tick: t, notes: pickTopNotes(tickMap.get(t), 3) }));
    const tableRows = rows.map((r, idx) => {
      const nextTick = (idx < rows.length - 1) ? rows[idx+1].tick : r.tick;
      const delta = nextTick - r.tick;
      return { tick: r.tick, delta, notes: r.notes };
    });

    // Render table
    resultBody.innerHTML = "";
    tableRows.forEach(row => {
      const tr = document.createElement('tr');
      const tdTick = document.createElement('td'); tdTick.textContent = row.tick;
      const tdDelta = document.createElement('td'); tdDelta.textContent = row.delta;
      const tdNotes = document.createElement('td'); tdNotes.textContent = row.notes.map((n,i)=>`${n.instrumentName} (${n.note})`).join(', ');
      tr.appendChild(tdTick); tr.appendChild(tdDelta); tr.appendChild(tdNotes);
      resultBody.appendChild(tr);
    });

    // Prepare export JSON (intermediate format)
    lastExportData = {
      meta: {
        sourceFile: midiFile.name,
        generatedAt: new Date().toISOString(),
        referenceBPM: defaultBpm,
        mcTicksPerSecond: 20
      },
      layout: {
        maxNotesPerTick: 3,
        baseY: 0
      },
      ticks: tableRows.map((r) => ({
        tick: r.tick,
        delta: r.delta,
        notes: r.notes.map((n, i) => ({
          index: i,
          block: n.block,
          instrumentName: n.instrumentName,
          note: n.note,
          midi: n.midi,
          velocity: n.velocity
        }))
      }))
    };

    downloadJsonBtn.style.display = "inline-block";
    downloadSchemBtn.style.display = "inline-block";
    infoBPM.textContent += ` — ticks: ${tableRows.length}, maxTick: ${tableRows.length?tableRows[tableRows.length-1].tick:0}`;
  }

  // BUTTONS
  processBtn.addEventListener('click', async () => {
    processBtn.disabled = true;
    try { await processMidi(); }
    catch(err){ console.error(err); alert('Error processing MIDI: ' + err.message); }
    finally { processBtn.disabled = false; }
  });

  downloadJsonBtn.addEventListener('click', () => {
    if (!lastExportData) return alert('Process a MIDI file first.');
    const blob = new Blob([JSON.stringify(lastExportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = (midiFile?.name?.replace(/\.mid$/i,'') || 'notetrasform') + '.noteblocks.json';
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  });

  // Generate .schem client-side using prismarine-nbt.writeUncompressed
  downloadSchemBtn.addEventListener('click', async () => {
    if (!lastExportData) return alert('Process a MIDI file first.');

    const ticks = lastExportData.ticks;
    if (!ticks.length) return alert('No ticks to export.');

    // compute dimension X = maxTick+1 (we place columns at tick index)
    const maxTick = Math.max(...ticks.map(t => t.tick));
    const Width = maxTick + 1;
    const Height = (lastExportData.layout.baseY || 0) + 4; // base + up to 3 notes stacked
    const Length = 1;

    // Build Palette (map block name -> id)
    const Palette = { "minecraft:air": 0 };
    let nextPaletteId = 1;
    // ensure note_block present
    Palette["minecraft:note_block"] = nextPaletteId++;

    const Blocks = [];

    // iterate ticks: create note_block and supporting block below
    progressWrap.style.display = "inline-flex";
    progressBar.max = ticks.length;
    progressBar.value = 0;
    progressText.textContent = `0 / ${ticks.length} ticks`;

    for (let i = 0; i < ticks.length; i++) {
      const row = ticks[i];
      // for each note in row (0..2)
      for (const n of row.notes) {
        // ensure palette id for support block
        const supportName = n.block || "minecraft:stone";
        if (Palette[supportName] == null) Palette[supportName] = nextPaletteId++;
        // place support block at Y = baseY + n.index (so stacked vertically)
        Blocks.push({
          Name: supportName,
          Pos: [row.tick, (lastExportData.layout.baseY || 0) + n.index, 0],
          States: {}
        });
        // place note_block above (Y = baseY + 1 + index)
        Blocks.push({
          Name: "minecraft:note_block",
          Pos: [row.tick, (lastExportData.layout.baseY || 0) + 1 + n.index, 0],
          States: { note: String(n.note) }
        });
      }

      // update progress UI (yield so DOM updates)
      progressBar.value = i + 1;
      progressText.textContent = `${i + 1} / ${ticks.length} ticks`;
      await new Promise(r => setTimeout(r, 0));
    }

    // Build NBT structure: Width, Height, Length, Palette, Blocks
    const nbt = {
      type: "compound",
      name: "",
      value: {
        Width: { type: "short", value: Width },
        Height: { type: "short", value: Height },
        Length: { type: "short", value: Length },
        Palette: {
          type: "compound",
          value: Object.fromEntries(
            Object.entries(Palette).map(([name,id]) => [name, { type: "int", value: id }])
          )
        },
        Blocks: {
          type: "list",
          value: {
            type: "compound",
            value: Blocks.map(b => ({
              Name: { type: "string", value: b.Name },
              Pos: { type: "list", value: b.Pos.map(p => ({ type: "int", value: p })) },
              States: { type: "compound", value: Object.fromEntries(Object.entries(b.States || {}).map(([k,v]) => [k, { type: "string", value: v }])) }
            }))
          }
        }
      }
    };

    try {
      // writeUncompressed returns an ArrayBuffer-like; prismarine-nbt returns a Buffer-like (Uint8Array)
      const buffer = writeUncompressed(nbt);
      const blob = new Blob([buffer], { type: "application/octet-stream" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = (midiFile?.name?.replace(/\.mid$/i,'') || 'notetrasform') + '.schem';
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
      infoBPM.textContent = `Schematic ready — downloaded. Width:${Width} Height:${Height} Length:${Length}`;
    } catch (err) {
      console.error(err);
      alert("Error generating .schem: " + err.message);
    } finally {
      progressWrap.style.display = "none";
    }
  });

  </script>
</body>
</html>
